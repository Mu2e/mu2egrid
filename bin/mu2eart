#!/usr/bin/perl -w
#
# A frontend script to submit mu2e framework jobs to Fermilab grid.
#
# A.Gaponenko, 2012
#
use File::Basename;
use Getopt::Long;
use Cwd 'abs_path';
use POSIX qw(ceil);

use Data::Dumper; # for debugging

use lib dirname($0);
use mu2egrid;

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage:
        $self --setup=<script-to-source.sh> \\
              --fcl=<file> \\
              --njobs=<M> \\
              {--inputs=<filelist>|--events-per-job=<N> [--run-number=<R>]} \\
              [--jobname=<name>] \\
              [--TFileService=<name>] \\
              [--geometry=<name>] \\
              [--fclinput=[numFiles:]<fclVarName>:<filelist>] \\
              [--userscript=<script>] \\
EOF
. mu2egrid::commonOptDoc1() . <<EOF

    - The --setup argument must point to the setup.sh script in a user
      Offline area.

    - The --inputs filelist provides a list of framework ROOT
      files to be processed by the job.  This is mutually exclusive
      with --events-per-job, the latter being used for jobs that
      generate new events.  Each process pre-stages its subset of
      input files to a local disk on the worker node.

    - For new event generation one may specify the run number, the
      default is the Condor cluster number.

    - The jobname argument defines the name of the top level output
      directory.  If this parameter is not specified, a name will be
      derived from the fcl file name.

    - The --TFileService option sets the output histogram filename.
      Given filename will be passed over to Offline mu2e as the
      argument of -T option.

    - The --geometry option sets the geometry configuration file.
      The style of path of input filename valuable should be the
      same with services.user.GeometryService.inputFile in fcl file,
      which assumes the Offline path. It should not be absolute or
      relative path from `pwd`.

    - The --fclinput option sets the given fcl file variable so that
      it points to the files in the given filelist.  The files are
      pre-staged to the worker node.  If numFiles is specified, only
      the given number of randomly selected files from the list are
      used, rather than the complete list.  The --fclinput option can
      be repeated several times, the effect is cumulative.  If
      fclVarName starts with the '\@' sign, it will generate a
      BEGIN_PROLOG/END_PROLOG block with a fclVarName definition,
      which should be referred to using the \@local::fclVarName syntax
      in the user fcl file.  If the variable name does not start with
      the '\@' sign, an assignment to that variable will be appended to
      the user fcl file.

    - The optional --userscript program receives the name of the
      generated fcl file as the first command line argument, the
      sequential process number (0 to njobs-1) as the second argument,
      and the total number of jobs in this cluster as the third.  The
      program is executed after the process-specific fcl file is
      generated and before the mu2e command is run.  The program may
      modify the fcl file and/or do any other adjustments to the job.
      The process is aborted unless the program exits with zero status
      code.

EOF
. mu2egrid::commonOptDoc2()
;
}

#================================================================
my @fclinputs;
my @extra_jobsub_args;
my @files_to_transfer;

my %opt =
    ('fclinput' => \@fclinputs,
    'jobsub-arg' => \@extra_jobsub_args,
    );

@opt{keys %mu2egrid::commonOptDefaults}  =  values %mu2egrid::commonOptDefaults;

# Process command line opts.
GetOptions(\%opt,
    'setup=s',
    'fcl=s',
    'njobs=i',
    'inputs=s', 'events-per-job=i', 'run-number=i',
    'jobname=s',
    'TFileService=s',
    'geometry=s',
    'fclinput=s',
    'userscript=s',
    @mu2egrid::commonOptList)
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

print "Final set of options:\n", Dumper( \%opt ), "\n"
    if($opt{'verbose'});


# Check that all of the required args are present:
foreach my $k ('setup', 'mu2e-setup', 'fcl', 'outstage', 'njobs') {
    defined $opt{$k} or die "Error: --$k must be specified.  Try the --help option.\n";
}

#----------------
# All file args are to be passed to the worker node script using full path names.
my $setup = mu2egrid::find_file($opt{'setup'});
my $mu2esetup = mu2egrid::find_file($opt{'mu2e-setup'});
my $fcl = mu2egrid::find_file($opt{'fcl'});
my $outstage = mu2egrid::find_file($opt{'outstage'});

mu2egrid::assert_known_outstage($outstage);

my $njobs = $opt{'njobs'};
my $test_queue = $opt{'test-queue'};
if($test_queue && ($njobs > 1)) {
    print "WARNING: trying to run more than one job while requesting --test-queue\n";
}

my $jobname;
if(defined $opt{'jobname'}) {
    $jobname = $opt{'jobname'};
}
else {
    $jobname = basename($fcl, ('.fcl',) );
}

$ENV{'MU2EGRID_USERSETUP'} = $setup;
$ENV{'MU2EGRID_MU2ESETUP'} = $mu2esetup;
$ENV{'MU2EGRID_OUTDIRFMT'} = "$jobname.%d/%05d";
$ENV{'MU2EGRID_OUTSTAGE'} = $outstage;
$ENV{'MU2EGRID_NCLUSTERJOBS'} = $njobs;

$ENV{'MU2EGRID_MASTERFHICL'} = basename($fcl);
push @files_to_transfer, $fcl;

my $whoami = `whoami`;
chomp($whoami);
$ENV{'MU2EGRID_SUBMITTER'} = $whoami;

# Either --inputs or --events-per-job is required.   The --run-number option is only combinable with the latter.
if(defined $opt{'inputs'}) {
    if(defined($opt{'events-per-job'})) {
        die "Arguments --inputs and --events-per-job are mutually exclusive.";
    }

    if(defined($opt{'run-number'})) {
        die "Arguments --inputs and --run-number are mutually exclusive.";
    }

    my $inputs = mu2egrid::find_file($opt{'inputs'});
    mu2egrid::validate_file_list($inputs);

    $ENV{'MU2EGRID_INPUTLIST'} = basename($inputs);
    push @files_to_transfer, $inputs;

    my $nlines =  `cat $inputs | wc -l`;
    chomp($nlines);
    print "nlines = $nlines in file $inputs\n" if $opt{'verbose'};

    if($nlines < $njobs) {
        die "Error too many requested jobs = $njobs.  The input file list has only $nlines lines: $inputs\n";
    }
    $ENV{'MU2EGRID_CHUNKSIZE'} = ceil($nlines/$njobs);

}
else {
    if(!defined($opt{'events-per-job'})) {
        die "Either --inputs or --events-per-job must be specified.";
    }

    $ENV{'MU2EGRID_EVENTS_PER_JOB'} = $opt{'events-per-job'};

    if(defined($opt{'run-number'})) {
        $ENV{'MU2EGRID_RUN_NUMBER'} = $opt{'run-number'};
    }
}

#----------------
# Handle the --userscript options
if(defined($opt{'userscript'})) {
    $userscript = mu2egrid::find_file($opt{'userscript'});
    die "Error: file \"$userscript\" is not executable\n"
        unless -x $userscript;
    $ENV{'MU2EGRID_USERSCRIPT'} = $userscript;
}

#----------------
# Handle TFileService output name
if(defined($opt{'TFileService'})) {
    $tfileservice = $opt{'TFileService'};
    $ENV{'MU2EGRID_TFILESERVICE'} = $tfileservice;
}

#----------------
# Handle geometry file
if(defined($opt{'geometry'})) {
    $geometry = $opt{'geometry'};
    $ENV{'MU2EGRID_GEOMETRY'} = $geometry;
}

#----------------
# Handle the --fclinput options
$ENV{'MU2EGRID_FCLINPUT_NUMENTRIES'}=0;
foreach my $fclin (@fclinputs) {

    die "Error in an --fclin specification: no ':' in $fclin\n" unless $fclin =~ /:/;

    my $numFiles = 0; # the default
    my $var;
    my $files;
    (my $l1, my $l2) = split(/:/, $fclin, 2);
    if($l1 =~ /^\d/) {
        die "Invalid numFiles=$l1  in --fclinput=$fclin\n"
            unless $l1 =~ /^\d+$/;
        $numFiles = $l1;
        die "Error in an --fclin specification: no 'filelist' part in $fclin\n" unless $l2 =~ /:/;
        ($var, $files) = split(/:/, $l2, 2);
    }
    else {
        ($var, $files) = ($l1, $l2);
    }

    $files = mu2egrid::find_file($files);
    mu2egrid::validate_file_list($files);

    $ENV{'MU2EGRID_FCLINPUT_NUMENTRIES'} += 1;
    my $prefix = "MU2EGRID_FCLINPUT_$ENV{MU2EGRID_FCLINPUT_NUMENTRIES}";
    $ENV{$prefix . '_NF'} .= "$numFiles";
    $ENV{$prefix . '_VAR'} .= "$var";
    $ENV{$prefix . '_FILELIST'} .= "$files";
}

#----------------
# Handle the --prestage-spec options
if(defined($opt{'prestage-spec'})) {
    $prestage = mu2egrid::find_file($opt{'prestage-spec'});
    mu2egrid::validate_prestage_spec($prestage);
    $ENV{'MU2EGRID_PRESTAGE'} = basename($prestage);
    push @files_to_transfer, $prestage;
}

#----------------------------------------------------------------
my @args;

push @args, ('--group', $opt{'group'});
if(defined($opt{'role'})) {
    push @args, ('--role', $opt{'role'});
}
push @args, ('--jobsub-server', $opt{'jobsub-server'});
push @args, ('--disk', $opt{'disk'});
push @args, ('--memory', $opt{'memory'});
push @args, ('--OS', $opt{'OS'});
push @args, ('--resource-provides', $opt{'resource-provides'});
push @args, @extra_jobsub_args;

# IFDH_VERSION in the environment is used by both jobsub and our worker node scripts.
# This is why we don't use the MU2EGRID_ prefix for this var.
$ENV{'IFDH_VERSION'} = $opt{'ifdh-version'} // $ENV{'IFDH_VERSION'} // mu2egrid::default_package_version($opt{'mu2e-setup'}, 'ifdhc', '');
print "Will use ifdh version $ENV{IFDH_VERSION}\n";

# Export the EXPERIMENT variable for ifdh
push @args, ('-e', 'EXPERIMENT');

if($test_queue) {
    push @args, '--test_queue';
}

while( (my $key, my $value) = each(%ENV) ) {
    if(($key =~ m/^MU2EGRID_\w+$/) or ($key eq 'IFDH_VERSION')) {
        # jobsub_client does not allow empty string as environment values
        if(defined $value and $value ne '') {
            push @args,  ('-e', $key);
            print "Using: $key => $ENV{$key}\n" if $opt{'verbose'};
        }
    }
}


my %filecheck;
foreach my $f (@files_to_transfer) {
    push @args, ('-f', $f);
    my $bn = basename($f);
    if(defined($filecheck{$f})) {
        die "Error: duplicate file name $f on the transfer list\n";
    }
    $filecheck{$f} = 1;
}

push @args, ('-N', $njobs);

push @args, 'file://' . $mu2egrid::impldir . '/copyback.sh';
push @args, $mu2egrid::impldir . '/mu2eart.sh';

print "Command:  $mu2egrid::jobsub @args\n";
if(!$opt{'dry-run'}) {
    print "Submitting....\n";
    exec { $mu2egrid::jobsub } $mu2egrid::jobsub, @args
        or die "Error executing $mu2egrid::jobsub: $!";
}
else {
    print "Not submitting because --dry-run was requested.\n";
}

#================================================================
