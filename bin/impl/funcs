# -*-Shell-script-*-
#
# Common functions for worker node scripts.
#
# Andrei Gaponenko, 2012
#
#
#================================================================
SeedServiceMaxEngines=20
generateSeed() {
    # art's RandomNumberGenerator_service restrict seeds to
    # not exceed 900000000.   Not clear if zero seed is OK
    # so we'll use a non-negative number up to the max.
    # Should leave space for SeedService to increment, thus -20.
    seed=0
    maxseed=$((900000001 - $SeedServiceMaxEngines))
    while [ "$seed" -le 0 ]; do 
	seed=$(( $(od --format u4 --read-bytes 4 /dev/urandom | head -1| awk '{print $2}') % maxseed ))
    done
    echo $seed
}

#================================================================
# prints a set of nr integers between 0 and (range-1), inclusive.
getDistinctRandoms() {
    range=${1:?getDistinctRandoms: range arg is missing}
    nr=${2:?getDistinctRandoms: numRandoms arg is missing}
    if [ $range -gt 32768 ]; then
       # we use bash RANDOM here
       echo "ERROR: getDistinctRandoms: range=$range is not supported: max is 32768" >&2
       return 1
    elif [ $range -lt $nr ]; then
       echo "ERROR: getDistinctRandoms: inconsistent args: range=$range, nr=$nr" >&2
       return 1
    else
	rlist=''
	while [ $(for i in $rlist; do echo $i; done|wc -l) -lt $nr ]; do
	    rlist+=" $(($RANDOM%$range))"
	    rlist="$(for i in $rlist; do echo $i; done|sort -n -u)"
	done
	echo $rlist   
    fi
}

#================================================================
# prints a requested number of lines, selecting random distinct lines
# from the given file
pickRandomLines() {
    file="${1:?pickRandomLines: file arg is missing}"
    nl=${2:?pickRandomLines: numLines arg is missing}
    rlist=$(getDistinctRandoms $(wc -l $file|awk '{print $1}') $nl)
    for ll in $rlist; do
	tail --lines=+"$((1+$ll))" "$file" | head --lines=1
    done
}

#================================================================
# This cuts a chunk of inputs for this job from the master input file list.
# The resulting list gives "remote" files names that are to be staged in.
createInputFileList() {
    masterlist=${1:?createInputFileList: masterlist arg missing}
    chunksize=${2:?createInputFileList: chunksize arg missing}
    process=${3:?createInputFileList: process arg missing}

    firstline=$((1 + $chunksize * $process))
    
    mylist="mu2eRemoteInputFiles.txt"
    tail --lines=+"$firstline" "$masterlist" | head --lines="$chunksize" > "$mylist"
    echo "$mylist"
}

#================================================================
# This function creates a "prestage specification" file from
# a list of remote input event files.
createPrestageSpec() {
    remotelist=${1:?createPrestageSpec: remotelist arg missing}
    specfile=${2:-"events_prestage.spec"}

    cat $remotelist | while read rfn; do
	lfn="data/$(echo $rfn|sed -e 's|/|-|g')"
	echo $rfn $lfn >> $specfile
    done

    echo "$specfile"
}

#================================================================
# This function creates a list of local files from a prestage
# specification file.
extractLocalList() {
    specfile=${1:?extractLocalList: specfile arg missing}
    locallist="mu2eLocalInputFiles.txt"
    awk '{print $2}' $specfile > $locallist
    echo "$locallist"
}

#================================================================
# This function takes an arbitrary number of "prestage specification"
# files, and copies all the remote files to their destinations
# under an I/O throttling protection.
stageIn() {

    ret=0

    declare -a specs
    for f in "$@"; do
	if [ -n "$f" ]; then
	    specs=("${specs[@]}" $f)
	fi
    done

    if [ "${#specs[@]}" -gt 0 ]; then

	echo "$(date) # Starting to pre-stage input files"
	type ifdh

	# Merge all the lists into a single file
	# ifdh is picky about white spaces, (redmine #3790)
	# Make sure we have exactly one space
	totalspec=$(mktemp prestage-merged.XXXX)
	awk '{print $1" "$2}' "${specs[@]}" > "$totalspec"

	# ifdh does not create destination directories
        # Do it here
	mkdir -p $(awk '{print $2}' "$totalspec" | sed -e 's|/[^/]*$||' | sort -u)

	awk '{print "Pre-staging: ",$1,"  ==>  ",$2}' "$totalspec"

	tstart=$(date +%s)

	# Get the lock and copy files
	# We have to force the use of gridftp to handle a mix of bluearc and pnfs files (INC000000418568)
	IFDH_FORCE=gridftp ifdh cp -f "$totalspec"
	ret=$?

	t2=$(date +%s)
	echo "$(date) # Total stage-in time: $((t2-tstart)) seconds, status $ret"

    fi

    return $ret
}

#================================================================
printinfo() {
    echo Starting on host `uname -a` on `date`
    echo running as user `whoami`
    echo "current work dir is $(/bin/pwd)"
    echo OS version `cat /etc/redhat-release`
    echo "job arguments: $@"
    echo "The environment is:"
    /usr/bin/printenv
    echo "================================================================"
    echo "Visible disk space:"
    df -P
    echo "================================================================"
    echo "TMPDIR: ls -al"
    ls -al "$TMPDIR"
    echo "TMPDIR: df -h"
    df -h "$TMPDIR"
}
#================================================================
createOutStage() {
    # Copy arguments into meaningful names.
    outstagebase=${1:?createOutStage: outstagebase missing}
    user=${2:?createOutStage: user missing}
    jobname=${3:?createOutStage: jobname missing}
    cluster=${4:?createOutStage: cluster missing}
    process=${5:?createOutStage: process missing}

    outtop="${outstagebase}/$user/${jobname}.${cluster}"
    outstage="${outtop}/$(printf '%05d' $process)"

    # There are cases when a job fails after creating the outstage
    # directory then automatically restarted by condor.  We don't want
    # to loose the output from the restarted job.  It is also good to
    # preserve whatever was transmitted by the first instance for a
    # post-mortem analysis.  Just rename a pre-existing directory.
    # There should be no race condition as the previous instance of
    # this process should be dead before a new one is started.

    if [ -d "$outstage" ]; then
	/bin/mv "$outstage" $(mktemp -u "$outstage".XXX)
    fi

    mkdir -p --mode 0775 "${outstage}" && echo "${outstage}"
}
#================================================================
# Ignores directories and other non-plain files
selectFiles() {
    for i in "$@"; do
	[ -f "$i" ] && [ ! -h "$i" ] && echo "$i"
    done
}
#================================================================
filterOutProxy() {
    for i in "$@"; do
	case "$i" in
	    *.proxy)
            # Don't expose security sensitive info
		true;;
	    *) 
		echo "$i";;
	esac
    done
}
#================================================================
createManifest() {
    ls -l |awk '{print "# "$0}' > manifest
    echo '#----------------------------------------------------------------' >> manifest
    echo '# algorithm: sha256sum' >> manifest
    sha256sum "$@" >> manifest
    sc="$(sha256sum < manifest)"
    echo "# selfcheck: $sc" >> manifest
    echo manifest
}
#================================================================
transferOutFiles() {
    echo "$(date) # Starting to transfer output files"
    type ifdh

    OUTDIR="${1:?transferOutFiles: OUTDIR arg missing}"
    shift

    MANIFEST=$(createManifest "$@")

    t1=$(date +%s)

    ifdh cp --force=expftp -D  "$MANIFEST" "$@" ${OUTDIR}

    t2=$(date +%s)
    echo "$(date) # Total outstage lock and copy time: $((t2-t1)) seconds"
}
#================================================================
